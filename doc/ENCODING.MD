# Function encoding

Used extensively by the library is the following instruction encryption scheme. It is designed to not fully scramble the instructions into apparent random noise, but rather to distort them into other, valid instructions such that a reverse engineer may not even realize they were encoded.

The included tool `elfcoder` is capable of both encrypting and decrypting to this specification.

### Background

ARM instructions are 32 bits wide. This version of the library does not support Thumb.

The range of instructions to be encrypted is demarcated using specific macros, like so:

```c
u32 foo(u32 x) {
    ENCRYPTION_START(0x1234);
    
    // Arbitrary secret steps
    x = (x * 177) + 16;
    x = (x << 4) ^ (x >> 7) ^ (x << 1);
    
    ENCRYPTION_END(0x1234);
    
    return x;
}
```

where `0x1234` is the encryption key. Only the instructions generated between the two macros will receive encryption.

Programmatically, the range is determined by searching for the occurrence of the matching key in the opposite macro. That is, the `ENCRYPTION_START` macro will search forward looking for a key matching `0x1234`, as is present in the `ENCRYPTION_END` macro, and decrypt all instructions between that and its own copy of the key. Inversely, the `ENCRYPTION_END` macro does the same searching backwards.

The actual definition of these macros is inline assembly which calls helper functions with the current `pc` as argument. For details on this, see [ASSEMBLY.MD](./ASSEMBLY.MD).

### Instruction encryption

A modified version of the RC4 stream cipher algorithm is used to generate pseudorandom bytes.

When encrypting and decrypting, the instruction is treated as a little-endian four byte value, and processed as follows:

- The first byte is exclusive-ored with the next byte from the RC4 generator.

- The second byte is exclusive-ored with the next byte from the RC4 generator.

- The third byte is substituted via an [S-box](https://en.wikipedia.org/wiki/S-box). However, this S-box is very weak: `S[i] = i âŠ• 1`. It is unknown why this was implemented using an S-box instead of simply exclusive-oring the value `0x01` directly.

- The fourth byte is left unmodified.

This process, as its own inverse, is identical for decryption.

### Encryption and linking

This encryption procedure is not compatible with linking. Linking will use relocations to alter the instructions after the fact, which will then not match up after the instruction is later decrypted to be run.

Therefore, no function calls may be made at all within an encrypted range.

A way around this is to use function pointers, where the address of the function is loaded into a variable from outside of an encrypted range, and can then be called from that variable, generating instructions that do not get relocated such as `blx ip`.

## RC4

*See the [Wikipedia article on RC4](https://en.wikipedia.org/wiki/RC4) for background information on this algorithm.*

RC4 is initialized anew for each instruction range that is being encrypted, and bytes are generated by it as the instructions are encoded from top to bottom.

The authors have made one bizarre modification: during key scheduling, rather than counting the array `S` index `i` up from 0 to 255, it instead counts down from 255 to 0. Key indexing still starts at 0 and increments upwards normally.

The key size is always 128 bits.

### Key generation

The 128-bit RC4 key is derived from a 16-bit seed key, prepended with `0xEB00` to create a 32-bit value.

This 32-bit value is then treated as a little-endian set of four bytes. These four bytes are repeated four times to create a 16-byte value in total. Finally, the first and last byte are exclusive-ored with `0xFF` to produce the final 16-byte key.

For example, the seed key `0x1234` would become the 32-bit value `0xEB001234`, which would then produce the key:

```
CB 12 00 EB 34 12 00 EB 34 12 00 EB 34 12 00 14
```

This key would then produce the keystream:

```
5A 88 0B 5D E1 53 59 E0 88 74 98 9F 9F 6E 0B 3D 54 48 2E F7 13 B4 19 33 AB 7C D4 BE 2F 42 D3 33 ...
```
